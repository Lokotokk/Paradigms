# Контекст
# Есть такая операция в статистике - “нормализация”. Это операция принимающая на вход вектор и
# возвращающая другой вектор. Смысл этой операции в том, чтобы данные из разных шкал загнать в
# единый диапазон, как правило - от 0 до 1, тогда с данными становится проще работать.
#  Ваша задача
# Реализовать с использованием функциональной парадигмы процедуру normalization, которая выполняет
# нормализацию полученного массива по приведенной формуле нормализованного значения элемента, где
#  x_norm - нормализованное значение элемента
#  x - исходное значение элемента
#  x_max, x_min - максимальное и минимальное значение в массиве
# ● Решение.. ?


# list_1 = [4, 11, 6, 31] # 

# def normalization(my_array: list) -> list:
#     x_max = max(list_1)
#     x_min = min(list_1)
#     return list(map(lambda x: round((x - x_min) / (x_max - x_min), 2), list_1))

# print(normalization(list_1))

# def normalization(my_array):
#     x_max = max(my_array)
#     x_min = min(my_array)
#     for x in range(len(my_array)):
#         x_norm = (my_array[x] - x_min) / (x_max - x_min)
#         my_array[x] = x_norm
#     return my_array

# print(normalization(list_1))



# Контекст
# Предположим, что есть какой-то массив содержащий данные о разных людях и их возрасте и вас
# попросили ответить на следующий вопрос: “сколько в массиве людей возраста > 30?”. Для этого, вы
# хотите написать программу для фильтрации наблюдений по возрастному признаку.
# ● Ваша задача
# Написать скрипт принимающий на вход массив с данными о людях и число - возраст, а возвращающий
# число - количество людей старше указанного возраста.
# ● Решение.. ?


# data = [{"name": "Sergey", "age": 35}, {"name": "Maxim", "age": 31}, {"name": "Alex", "age": 26}]

# def count_people(some_data):
#     return sum(map(lambda x: x["age"] > 30, data))

# print(count_people(data))


# Контекст
# Важнейшая задача в анализе данных - поиск дубликатов. Дубликат - это наблюдение, встречающееся в
# данных больше одного раза. Такие наблюдения не просто не улучшают результат анализа или
# полученных моделей, но и замедляют весь процесс в целом, поэтому аналитики и разработчики
# предпочитают избавляться от них перед тем как приступить к анализу.
# ● Ваша задача
# Реализовать с использованием функциональной парадигмы процедуру для поиска дубликатов. На вход
# подается массив, где могут присутствовать дубликаты (а могут и не присутствовать). При применении к
# массиву, дубликаты должны быть выведены на экран в виде списка.
# ● Решение.. ?

my_list = [1, 2, 1, 3, 4, 3, 3, 3, 5, 5, 6, 7, 8, 8, 9, 9, 9]
sort_list = sorted(my_list)
print(sort_list)

for i in range(len(sort_list) - 1):
    if sort_list[i] == sort_list[i + 1]:
        print(sort_list[i + 1])

